/****************************************************************************
*
*    Copyright (c) 2019 Vivante Corporation
*
*    Permission is hereby granted, free of charge, to any person obtaining a
*    copy of this software and associated documentation files (the "Software"),
*    to deal in the Software without restriction, including without limitation
*    the rights to use, copy, modify, merge, publish, distribute, sublicense,
*    and/or sell copies of the Software, and to permit persons to whom the
*    Software is furnished to do so, subject to the following conditions:
*
*    The above copyright notice and this permission notice shall be included in
*    all copies or substantial portions of the Software.
*
*    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
*    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
*    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
*    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
*    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
*    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
*    DEALINGS IN THE SOFTWARE.
*
*****************************************************************************/

/**
* Apply postprocessing steps to bounding box detections.
*
* Bounding box detections are generated by applying transformation on a set
* of predefined anchors with the bounding box deltas from bounding box
* regression. A final step of hard NMS is applied to limit the number of
* returned boxes.
*
* Supported tensor {@link OperandCode}:
* * {@link ANEURALNETWORKS_TENSOR_FLOAT16}
* * {@link ANEURALNETWORKS_TENSOR_FLOAT32}
*
* Inputs:
* * 0: A 3-D Tensor of shape [batches, num_anchors, num_classes], specifying
*      the score of each anchor with each class. Class 0 for each
*      [batches, num_anchors, 0] is background and will be ignored.
* * 1: A 3-D Tensor of shape [batches, num_anchors, length_box_encoding], with
*      the first four values in length_box_encoding specifying the bounding
*      box deltas. The box deltas are encoded in the order of [dy, dx, dh, dw],
*      where dy and dx is the linear-scale relative correction factor for the
*      center position of the bounding box with respect to the width and height,
*      dh and dw is the log-scale relative correction factor for the width and
*      height. All the entries in length_box_encoding beyond the first four
*      values are ignored in this operation.
* * 2: A 2-D Tensor of shape [num_anchors, 4], specifying the shape of each
*      predefined anchor, with format [ctr_y, ctr_x, h, w], where ctr_y and
*      ctr_x are the center position of the box, and h and w are the height
*      and the width.
* * 3: An {@link ANEURALNETWORKS_FLOAT32} scalar, specifying the scaling
*      factor for dy in bounding box deltas.
* * 4: An {@link ANEURALNETWORKS_FLOAT32} scalar, specifying the scaling
*      factor for dx in bounding box deltas.
* * 5: An {@link ANEURALNETWORKS_FLOAT32} scalar, specifying the scaling
*      factor for dh in bounding box deltas.
* * 6: An {@link ANEURALNETWORKS_FLOAT32} scalar, specifying the scaling
*      factor for dw in bounding box deltas.
* * 7: An {@link ANEURALNETWORKS_BOOL} scalar, set to true to use regular
*      multi-class NMS algorithm that do NMS separately for each class,
*      set to false for a faster algorithm that only do one single NMS
*      using the highest class score..
* * 8: An {@link ANEURALNETWORKS_INT32} scalar, max_num_detections, specifying
*      the maximum number of boxes for the output. Boxes with the lowest
*      scores are discarded to meet the limit.
* * 9: An {@link ANEURALNETWORKS_INT32} scalar, only used when input7 is
*      set to false, specifying the maximum number of classes per detection.
* * 10: An {@link ANEURALNETWORKS_INT32} scalar, only used when input7 is
*       set to true, specifying the maximum number of detections when
*       applying NMS algorithm for each single class.
* * 11: A scalar, score_threshold. Boxes with scores lower than the
*       threshold are filtered before sending to the NMS algorithm. The
*       scalar must be of {@link ANEURALNETWORKS_FLOAT16} if input0 is of
*       {@link ANEURALNETWORKS_TENSOR_FLOAT16} and of {@link
*       ANEURALNETWORKS_FLOAT32} if input0 is of {@link
*       ANEURALNETWORKS_TENSOR_FLOAT32}.
* * 12: A scalar, specifying the IoU threshold for hard NMS. The scalar
*       must be of {@link ANEURALNETWORKS_FLOAT16} if input0 is of {@link
*       ANEURALNETWORKS_TENSOR_FLOAT16} and of {@link
*       ANEURALNETWORKS_FLOAT32} if input0 is of {@link
*       ANEURALNETWORKS_TENSOR_FLOAT32}.
* * 13: An {@link ANEURALNETWORKS_BOOL} scalar, set to true to include
*       background class in the list of label map for the output, set
*       to false to not include the background. When the background
*       class is included, it has label 0 and the output classes start
*       at 1 in the label map, otherwise, the output classes start at 0.
*
* Outputs:
* * 0: A 2-D tensor of the same {@link OperandCode} as input0, with shape
*      [batches, max_num_detections], specifying the score of each output
*      detections.
* * 1: A 3-D tensor of shape [batches, max_num_detections, 4], specifying the
*      coordinates of each output bounding box, with format
*      [y1, x1, y2, x2].
* * 2: A 2-D {@link ANEURALNETWORKS_TENSOR_INT32} tensor, of shape
*      [batches, max_num_detections], specifying the class label for each
*      output detection.
* * 3: An 1-D {@link ANEURALNETWORKS_TENSOR_INT32} tensor, of shape [batches],
*      specifying the number of valid output detections for each batch.
*
* Available since API level 29.
*/

#ifndef __AANEURALNETWORKS_DETECTION_POSTPROCESSING_HPP__
#define __AANEURALNETWORKS_DETECTION_POSTPROCESSING_HPP__

#include "api_requirement/spec_macros.hpp"

#define OP_SPEC_NAME DetectionPostprocessingOperation
OP_SPEC_BEGIN()
#define ARG_NAMES         \
    (input,               \
     bbox,                \
     anchor_shape,        \
     dy,                  \
     dx,                  \
     dh,                  \
     dw,                  \
     nms_type,            \
     max_num_detections,  \
     maximum_class_per_detection,\
     maximum_detection_per_class,\
     score_threshold,     \
     iou_threshold,       \
     is_bg_in_label)
#define ARGC BOOST_PP_TUPLE_SIZE(ARG_NAMES)

#define BOOST_PP_LOCAL_MACRO(n) OP_SPEC_ARG(BOOST_PP_TUPLE_ELEM(ARGC, n, ARG_NAMES))
#define BOOST_PP_LOCAL_LIMITS (0, ARGC)
#include BOOST_PP_LOCAL_ITERATE()
OP_SPEC_END()

// order of argument is important
MAKE_SPEC(detection_postprocessing)
    .input_(nnrt::OperandType::TENSOR_FLOAT32)
    .bbox_(nnrt::OperandType::TENSOR_FLOAT32)
    .anchor_shape_(nnrt::OperandType::TENSOR_FLOAT32)
    .dy_(nnrt::OperandType::FLOAT32)
    .dx_(nnrt::OperandType::FLOAT32)
    .dh_(nnrt::OperandType::FLOAT32)
    .dw_(nnrt::OperandType::FLOAT32)
    .nms_type_(nnrt::OperandType::BOOL)
    .max_num_detections_(nnrt::OperandType::INT32)
    .maximum_class_per_detection_(nnrt::OperandType::INT32)
    .maximum_detection_per_class_(nnrt::OperandType::INT32)
    .score_threshold_(nnrt::OperandType::FLOAT32)
    .iou_threshold_(nnrt::OperandType::FLOAT32)
    .is_bg_in_label_(nnrt::OperandType::BOOL)
    );

    OVERRIDE_SPEC(detection_postprocessing, 0)
    .input_(nnrt::OperandType::TENSOR_FLOAT16)
    .bbox_(nnrt::OperandType::TENSOR_FLOAT16)
    .anchor_shape_(nnrt::OperandType::TENSOR_FLOAT16)
    .score_threshold_(nnrt::OperandType::FLOAT16)
    .iou_threshold_(nnrt::OperandType::FLOAT16)
    );

#undef ARG_NAMES
#undef ARGC
#undef OP_SPEC_NAME

#endif